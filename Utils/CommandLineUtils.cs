using Kit;
using MalwareAdmin.Data;
using MalwareAdmin.ViewModels;
using System.Runtime.InteropServices;

namespace MalwareAdmin.Utils
{
    public class CommandLineUtils
    {
        public static bool ShowConsole = true;

        private static string ViperPath => _ViperPath.Value;
        private static readonly Lazy<string> _ViperPath = new Lazy<string>(() =>
        {
            string path = string.Empty;
            if (AppData.IsLinux)
            {
                string whereis = ExecuteAsync("cd /home", "ls", "exit").ConfigureAwait(false).GetAwaiter().GetResult();
                foreach (string homeFolder in whereis.Split("\n", StringSplitOptions.RemoveEmptyEntries))
                {
                    path = $"/home/{homeFolder}/.local/bin/";
                    whereis = ExecuteAsync($"cd {path}", "ls", "exit").ConfigureAwait(false)
                        .GetAwaiter().GetResult();
                    if (whereis.Split("\n", StringSplitOptions.RemoveEmptyEntries).Any(x => x.Trim() == "viper"))
                    {
                        return $"{path}viper";
                    }
                }
                if (string.IsNullOrEmpty(whereis?.Trim()))
                {
                    path = "viper";
                }
            }
            return path;
        });
        public static Task<string> ExecuteAsync(string command) => ExecuteAsync(new string[] { command });
        public static Task<string> ExecuteAsync(params string[] commands)
        {
            if (!commands.Any())
            {
                return Task.FromResult(string.Empty);
            }
            string newline = "\n\r";
            string terminal;
            if (AppData.IsWindows)
            {
                terminal = "wsl.exe";
            }
            else if (AppData.IsLinux)
            {
                terminal = ProcessContoller.LinuxTerminal;
                newline = "\n";
                for (int i = 0; i < commands.Length; i++)
                {
                    if (commands[i] == "viper")
                    {
                        commands[i] = ViperPath;
                    }
                }

                if (commands.Last() != "exit")
                {
                    commands = commands.Append("exit").ToArray();
                }
            }
            else if (AppData.IsOSX)
            {
                terminal = "sh";
            }
            else
            {
                throw new NotSupportedException($"Runtime operative system not recognized/supported [{RuntimeInformation.RuntimeIdentifier}]-[{RuntimeInformation.OSDescription}]");
            }

            return ExecuteCommandAsync(terminal, newline, commands);
        }
        private static async Task<string> ExecuteCommandAsync(string file, string newline = "\n\r", params string[] commands)
        {
            ProcessContoller contoller = ProcessContoller.Start(file);
            foreach (string command in commands)
            {
                if (command.Length == 1)
                {
                    await contoller.Write(command[0]);
                    continue;
                }
                await contoller.WriteLine(command);
            }
            contoller.Close();
            Tools.Container.Get<CommandLineViewModel>().Log(contoller.OutputData);
            return contoller.OutputData;
            //return await Task.Run(async () =>
            //{
            //    var cmdLog = Tools.Container.Get<CommandLineViewModel>();
            //    StringBuilder sb = new StringBuilder();
            //    using (var proc = new Process
            //    {
            //        StartInfo = new ProcessStartInfo
            //        {
            //            FileName = file,
            //            WindowStyle = ShowConsole
            //                       ? ProcessWindowStyle.Normal
            //                       : System.Diagnostics.ProcessWindowStyle.Hidden,
            //            CreateNoWindow = !ShowConsole,
            //            UseShellExecute = false,
            //            RedirectStandardOutput = true,
            //            RedirectStandardInput = true,
            //            RedirectStandardError = true,
            //            ErrorDialog = false,
            //        }
            //    })
            //    {

            //        proc.Start();
            //        //proc.StandardInput.AutoFlush = true;
            //        proc.BeginOutputReadLine();
            //        void DataReceived(object s, DataReceivedEventArgs e, bool isError)
            //        {
            //            if (string.IsNullOrEmpty(e.Data)) return;
            //            string data = e.Data.Replace("\0", string.Empty)?.Trim();
            //            if (string.IsNullOrEmpty(data)) return;
            //            if (data.StartsWith("Microsoft Windows") || data.Contains("Microsoft Corporation") ||
            //                data.Contains("PowerShell") || data == "viper >")
            //            {
            //                return;
            //            }
            //            cmdLog.Log(data, isError);
            //            sb.AppendLine(data);
            //        }
            //        proc.OutputDataReceived += (s, e) => DataReceived(s, e, false);
            //        proc.ErrorDataReceived += (s, e) => DataReceived(s, e, true);
            //        foreach (string command in commands)
            //        {
            //            await proc.StandardInput.WriteAsync($"{command}{newline}");
            //            await Task.Delay(300);
            //            await proc.StandardInput.FlushAsync();
            //            cmdLog.Log(command, true);
            //        }
            //        proc.StandardInput.Close();
            //        await proc.WaitForExitAsync(); // wait up to 5 seconds for command to execute
            //        proc.CancelOutputRead();
            //        string output = sb.ToString();
            //        if (string.IsNullOrEmpty(output))
            //        {
            //            output = proc.StandardError.ReadToEnd();
            //        }
            //        return output?.Trim() ?? string.Empty;
            //    }
            //});
        }
        public static string GetLastLine(string text)
        {
            if (string.IsNullOrEmpty(text))
            {
                return string.Empty;
            }
            string lastLine = text.Split("\r\n", StringSplitOptions.RemoveEmptyEntries)
                .LastDefault(x => !string.IsNullOrEmpty(x));
            if (string.IsNullOrEmpty(lastLine))
            {
                return text;
            }
            return lastLine;
        }
    }
}
