using Kit;
using MalwareAdmin.Data;
using MalwareAdmin.ViewModels;
using System.Runtime.InteropServices;

namespace MalwareAdmin.Utils
{
    public static class CommandLineUtils
    {
        public static bool ShowConsole = true;

        private static string ViperPath => _ViperPath.Value;
        private static readonly Lazy<string> _ViperPath = new Lazy<string>(() =>
        {
            string path = string.Empty;
            if (AppData.IsLinux)
            {
                string whereis = ExecuteAsync("cd /home", "ls", "exit").ConfigureAwait(false).GetAwaiter().GetResult();
                foreach (string homeFolder in whereis.Split("\n", StringSplitOptions.RemoveEmptyEntries))
                {
                    Console.WriteLine(homeFolder);
                    path = $"/home/{homeFolder}/.local/bin/";
                    whereis = ExecuteAsync($"cd {path}", "ls", "exit").ConfigureAwait(false)
                        .GetAwaiter().GetResult();
                    if (whereis.Split("\n", StringSplitOptions.RemoveEmptyEntries).Any(x => x.Trim() == "viper"))
                    {
                        return $"{path}viper";
                    }
                }
                path = "viper";
            }
            return path;
        });


        public static Task<string> ExecuteAsync(string command) => ExecuteAsync(CommandLineViewModel.BinBash, command);
        public static Task<string> ExecuteAsync(string command, CommandLineViewModel commandLine) => ExecuteAsync(commandLine, command);

        public static Task<string> ExecuteAsync(params string[] commands) => ExecuteAsync(CommandLineViewModel.BinBash, commands);
        public static Task<string> ExecuteAsync(CommandLineViewModel commandLine, params string[] commands)
        {
            if (!commands.Any())
            {
                return Task.FromResult(string.Empty);
            }
            string terminal;
            if (AppData.IsWindows)
            {
                terminal = "wsl.exe";
            }
            else if (AppData.IsLinux)
            {
                terminal = ProcessContoller.LinuxTerminal;
                for (int i = 0; i < commands.Length; i++)
                {
                    if (commands[i] == "viper")
                    {
                        commands[i] = ViperPath;
                    }
                }

                if (commands.Last() != "exit")
                {
                    commands = commands.Append("exit").ToArray();
                }
            }
            else if (AppData.IsOSX)
            {
                terminal = "sh";
            }
            else
            {
                throw new NotSupportedException($"Runtime operative system not recognized/supported [{RuntimeInformation.RuntimeIdentifier}]-[{RuntimeInformation.OSDescription}]");
            }

            return ExecuteCommandAsync(terminal, commandLine, commands);
        }
        private static async Task<string> ExecuteCommandAsync(string file, CommandLineViewModel commandLine = null, params string[] commands)
        {
            ProcessContoller contoller = ProcessContoller.Start(file);
            foreach (string command in commands)
            {
                if (command.Length == 1)
                {
                    await contoller.Write(command[0]);
                }
                else
                {
                    await contoller.WriteLine(command);
                }
                commandLine.Log(command, false);
            }
            contoller.Close();
            commandLine?.Log(contoller.OutputData);
            return contoller.OutputData;
        }
        public static string GetLastLine(string text)
        {
            if (string.IsNullOrEmpty(text))
            {
                return string.Empty;
            }
            string lastLine = text.Split("\r\n", StringSplitOptions.RemoveEmptyEntries)
                .LastDefault(x => !string.IsNullOrEmpty(x));
            if (string.IsNullOrEmpty(lastLine))
            {
                return text;
            }
            return lastLine;
        }
    }
}
